/*
 * generated by Xtext 2.14.0
 */
package org.xtext.slr.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.slr.reliSRS.Classification;
import org.xtext.slr.reliSRS.ConflictResolution;
import org.xtext.slr.reliSRS.DecisionPerUser;
import org.xtext.slr.reliSRS.Model;
import org.xtext.slr.reliSRS.Participants;
import org.xtext.slr.reliSRS.Phases;
import org.xtext.slr.reliSRS.ReliSRSPackage;
import org.xtext.slr.reliSRS.Result;
import org.xtext.slr.reliSRS.StatisticsOnExclusionCriteria;
import org.xtext.slr.services.ReliSRSGrammarAccess;

@SuppressWarnings("all")
public class ReliSRSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ReliSRSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ReliSRSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ReliSRSPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case ReliSRSPackage.CONFLICT_RESOLUTION:
				sequence_ConflictResolution(context, (ConflictResolution) semanticObject); 
				return; 
			case ReliSRSPackage.DECISION_PER_USER:
				sequence_DecisionPerUser(context, (DecisionPerUser) semanticObject); 
				return; 
			case ReliSRSPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ReliSRSPackage.PARTICIPANTS:
				sequence_Participants(context, (Participants) semanticObject); 
				return; 
			case ReliSRSPackage.PHASES:
				sequence_Phases(context, (Phases) semanticObject); 
				return; 
			case ReliSRSPackage.RESULT:
				sequence_Result(context, (Result) semanticObject); 
				return; 
			case ReliSRSPackage.STATISTICS_ON_EXCLUSION_CRITERIA:
				sequence_StatisticsOnExclusionCriteria(context, (StatisticsOnExclusionCriteria) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (question+=Question (response+=Response resultat+=Resultat)*)*
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConflictResolution returns ConflictResolution
	 *
	 * Constraint:
	 *     (cDecision+=CDecision | cNombre+=CNombre)*
	 */
	protected void sequence_ConflictResolution(ISerializationContext context, ConflictResolution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DecisionPerUser returns DecisionPerUser
	 *
	 * Constraint:
	 *     (dUser+=DUser | dIncluded+=DIncluded | dExcluded+=DExcluded | dInConflict+=DInConflict)*
	 */
	protected void sequence_DecisionPerUser(ISerializationContext context, DecisionPerUser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (projectName=ProjectName participants=Participants phase+=Phases* classification=Classification)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Participants returns Participants
	 *
	 * Constraint:
	 *     (participant+=Participant | role+=Role)*
	 */
	protected void sequence_Participants(ISerializationContext context, Participants semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Phases returns Phases
	 *
	 * Constraint:
	 *     (
	 *         phaseName=PhaseName 
	 *         decisionPerUser=DecisionPerUser 
	 *         statisticsOnExclusionCriteria=StatisticsOnExclusionCriteria 
	 *         conflictResolution=ConflictResolution 
	 *         result=Result
	 *     )
	 */
	protected void sequence_Phases(ISerializationContext context, Phases semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReliSRSPackage.Literals.PHASES__PHASE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReliSRSPackage.Literals.PHASES__PHASE_NAME));
			if (transientValues.isValueTransient(semanticObject, ReliSRSPackage.Literals.PHASES__DECISION_PER_USER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReliSRSPackage.Literals.PHASES__DECISION_PER_USER));
			if (transientValues.isValueTransient(semanticObject, ReliSRSPackage.Literals.PHASES__STATISTICS_ON_EXCLUSION_CRITERIA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReliSRSPackage.Literals.PHASES__STATISTICS_ON_EXCLUSION_CRITERIA));
			if (transientValues.isValueTransient(semanticObject, ReliSRSPackage.Literals.PHASES__CONFLICT_RESOLUTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReliSRSPackage.Literals.PHASES__CONFLICT_RESOLUTION));
			if (transientValues.isValueTransient(semanticObject, ReliSRSPackage.Literals.PHASES__RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReliSRSPackage.Literals.PHASES__RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPhasesAccess().getPhaseNamePhaseNameParserRuleCall_1_0_0(), semanticObject.getPhaseName());
		feeder.accept(grammarAccess.getPhasesAccess().getDecisionPerUserDecisionPerUserParserRuleCall_1_1_1_1_0(), semanticObject.getDecisionPerUser());
		feeder.accept(grammarAccess.getPhasesAccess().getStatisticsOnExclusionCriteriaStatisticsOnExclusionCriteriaParserRuleCall_1_1_2_1_0(), semanticObject.getStatisticsOnExclusionCriteria());
		feeder.accept(grammarAccess.getPhasesAccess().getConflictResolutionConflictResolutionParserRuleCall_1_1_3_1_0(), semanticObject.getConflictResolution());
		feeder.accept(grammarAccess.getPhasesAccess().getResultResultParserRuleCall_1_1_4_1_0(), semanticObject.getResult());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Result
	 *
	 * Constraint:
	 *     (rTotal=RTotal (rDecision+=RDecision | rPaper+=RPaper | rPourcentage+=RPourcentage)*)
	 */
	protected void sequence_Result(ISerializationContext context, Result semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatisticsOnExclusionCriteria returns StatisticsOnExclusionCriteria
	 *
	 * Constraint:
	 *     (sCriteria+=SCriteria | sNombre+=SNombre | sPourcentage+=SPourcentage)*
	 */
	protected void sequence_StatisticsOnExclusionCriteria(ISerializationContext context, StatisticsOnExclusionCriteria semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
